"use strict";

var net = require('net'),
    rl  = require('readline'),
    otg = require('./lib/otg_const'),
    ot  = require('./lib/ot_msg'),
    otf = require('./lib/ot_func');

// Map sensor types to Homey events
var sensorEventMap = {
	temperature: 'measure_temperature',
	pressure: 'measure_pressure',
	humidity: 'measure_humidity',
	co2: 'measure_co2',
	flow: '',
	percentage: '',
	binary: ''
};

var client; // Net client
var found = false; // True once an OpenTherm Gateway has been found
var searching = false; // Searching for OTG is in progress
var values = {}; // Values for all OpenTherm message values
var msg_supported = {}; // Will fill with supported messages
var searchCnt; // Nr of tries to find OTG
var map = {}; // Per OT variable name an array of devices: device func, device info ({func:, device: })
var features = { 'permanent': '1' };
var config = {}; // Configuration as stored in OTG

var self = module.exports = {
	// Open communication
	openComm: function(ip, port) {
		found = false; // openComm always triggers a new search
		searchCnt = 0;
		Homey.log('Starting search on ' + ip + ':' + port);
		if (client) {
			client.destroy();
		}
		var ok = ip != null && port != null;
		if (ok) {
			client = new net.Socket();
			var line = rl.createInterface(client, client);
			line.on('line', function(data) {
				otgProcessData(data);
			});
			client.on('error', function(err) {
				client.destroy();
			});
			client.connect(port, ip, function() {
				Homey.log('Connected to ' + ip + ':' + port);
				// Search for the OTG
				otgSearch(false);
			});
		}
		return ok;
	},
	// Check if we have found an OpenTherm Gateway
	checkFound: function() {
			return found;
	},
	// Set driver specific features
	setFeatures: function(settings) {
		var ok = settings != null;
		if (ok) {
			// TODO: input validation
			features = settings;
		}
		return ok;
	},
	getThermostats: function() {
		var devices = [{ 
				name: "Thermostat",
				data: { 
					id: "OTG:T1", 
					watch: [{ variable: 'CurrentSetpoint', event: 'target_temperature' },
						{ variable: 'CurrentTemperature', event: 'measure_temperature' },
						{ variable: 'StatusFlame', event: 'thermostat_state' }]
				},
			}];
		if (msg_supported[23]) {
			devices[1] = { 
				name: "Heating 2",
				data: { 
					id: "OTG:T2", 
					watch: [{ variable: 'CH2CurrentSetpoint', event: 'target_temperature' }]
				},
			};
		}
		return devices;
	},
	getSensors: function(sort) {
		var devices = [];
		var cnt = 0;
		for (var nr in ot.Messages) {
			var msg = ot.Messages[nr];
			// If sort is not defined, show all types, but only if the message already has a value.
			// We want to prevent to show sensors that are not supported by either boiler or thermostat.
			if ((sort == null || msg.sensor == sort) && values[msg.var]) {
				devices[cnt++] = {
					name: msg.txt,
					data: {
						id: 'OTG:' + nr,
						watch: [{ variable: msg.var, event: sensorEventMap[msg.sensor] }]
					}
				};
			}
		}
		return devices;
	},
	addDevice: function(func, device, sort) {
		Homey.log("Adding device " + device.id);
		if (device.watch) {
			device.watch.forEach(function(element) {
				if (map[element.variable] == null) {
					map[element.variable] = [];
				}
				Homey.log("Watching variable " + element.variable);
				if (element.get) {
					// We need to evaluate the function call at this point.
					element.get = eval(element.get);
				};
				// Add information of the device to our real-time update map
				map[element.variable].push({ func: func, device: device, event: element.event });
				// Immediately send a (forced) update of the variable if available
				otgUpdateIfNeeded(element.variable, values[element.variable], true);
			});
		}
	},
	deleteDevice: function(device) {
		Homey.log("Deleting device " + device.id);
		for (var id in device.watch) {
			// Remove this device from the map
			var name = device.watch[id].variable;
			Homey.log("Un-watching " + name);
			delete map[name];
		}
	},
	getValue: function(name) {
		return values[name];
	},
	setTargetTemp: function(device, value) {
		if (device.id == 'OTG:T1') {
			var cmd = 'TT='; // temporary temperature
			if (features['permanent'] == '1') {
				cmd = 'TC='; // constant temperature
			}
			client.write(cmd + value + '\r');
		} else {
			// TODO: figure out to use SR command
			Homey.log('Second thermostat not supported yet');
		}
	},
	getThermostatState: function(device) {
		var state = '<tbd>';
		if (values.StatusFlame !== null) {
			state = values.StatusFlame == 1 ? 'Heating' : 'Flame off';
		}
		return state;
	}
}

// Map Homey events to get functions
var eventGetMap = {
	'thermostat_state': self.getThermostatState
};

// Update variable value if needed and send message to Homey
function otgUpdateIfNeeded(name, newValue, forced) {
	if (name != null && newValue != null && (values[name] != newValue || forced)) {
		values[name] = newValue;
		Homey.log('Updating value of ' + name + ' to ' + newValue);
		if (map[name]) {
			map[name].forEach(function(element) {
				var get = eventGetMap[element.event];
				if (typeof get == 'function') {
					newValue = get(element.device);
				}
				Homey.log("Sending real-time event " + element.event + " for device " + element.device.id + ' (' + name + '=' + newValue + ')');
				element.func.realtime(element.device, element.event, newValue);
			});
		}
	}
}

// Search for OTG
function otgSearch() {
	if (found == false && searchCnt++ < 3) {
		client.write('PR=A\r');
		setTimeout(otgSearch, 1000);
		Homey.log("Search attempt " + searchCnt);
	}
}

// Local data processing function
function otgProcessData(data) {
	var str = String(data);
	var res = str.match(/(A|B|R|T)[0-9A-F]{8}/);
	if (res != null) { 
		// Found OpenTherm communication data
		var sender = otg.Initiator[str[0]];
		var ctype = otg.MsgType[parseInt(str[1], 16) & 0x7];
		var msg = parseInt(str.substr(3, 2), 16);
		if (ot.Messages[msg] != null) {
			var msgName = ot.Messages[msg].txt;
			var val1 = parseInt(str.substr(5, 2), 16);
			var val2 = parseInt(str.substr(7, 2), 16);
			var val = 0

			// Keep track of unsupported message IDs
			var override = (sender == "Answer" || sender == "Response");
			if ((ctype == "Read-Ack" || ctype == "Write-Ack") && msg_supported[msg] == null && override == false) {
				msg_supported[msg] = true;
			}
 
			// Determine if the value received will update the variable
			var valid = false;
			if (ctype == "Read-Ack") {
				valid = (override == true && msg_supported[msg] == null) || (override == false && msg_supported[msg] != null);
			} else if (ctype == "Write-Data") {
				valid = true;
			} else if (ctype == "Data-Invalid") {
				valid = override;
			}

			if (valid == true) {
				// Format value
				var msgVal = ot.Messages[msg].val;
				if (typeof msgVal === 'object') {
					val = otf.decode(val1, msgVal.hb) + ' ' + otf.decode(val2, msgVal.lb)
					var variable = ot.Messages[msg].var;
					if (variable != null) {
						otgUpdateIfNeeded(variable.hb, val1);
						otgUpdateIfNeeded(variable.lb, val2);
					}
				} else {
					val = otf.decode(val1, msgVal, val2)
					var variable = ot.Messages[msg].var;
					if (variable != null) {
						otgUpdateIfNeeded(variable, val);
					}
				}
				// If needed: format flags
				var msgFlags = ot.Messages[msg].flags;
				if (msgFlags != null) {
					msgFlags = ot[msgFlags];
					val = val1 * 256 + val2;
					for (var flag in msgFlags) {
						var item = msgFlags[flag];
						var flagVal = (val & parseInt(flag, 16)) ? 1 : 0;
						//Homey.log(">> " + item.txt + ": " + flagVal);
						if (item.var != null) {
							otgUpdateIfNeeded(item.var, flagVal)
						}
					}
				}
			}
			//Homey.log(res[0] + ' ' + sender + ', ' + ctype + ', ' + msgName + ': ' + val);
		 }else {
			Homey.log('Unknown OpenTherm message ID ' + msg);
		}
	} else if (str.match(/OpenTherm Gateway/) != null) {
		// Found PR=A (version information)
		var version = str.match(new RegExp(otg.Config.VER.ret));
		config.version = version;
		var fw_major = str.match(/\d/);
		found = true;
		Homey.emit('found');
		Homey.log("Found OpenTherm Gateway firmware version " + version[1]);
		// Update configuration based on version
		if (otg.VersionConfig[fw_major]) {
			var add = otg.VersionConfig[fw_major];
			for (var elem in add) { 
				otg.Config[elem] = add[elem]; 
			}
		}
		// Read Gateway settings to store them locally
		for (var i = 0; i < otg.Startup.length; i++) {
			var item = otg.Startup[i];
			if (otg.Config[item] && otg.Config[item].rep) {
				var cmd = 'PR=' + otg.Config[item].rep + '\r';
				client.write(cmd);
			}
		}
	} else {
		// Other OTG traffic
		Homey.log(str);
	}
}
