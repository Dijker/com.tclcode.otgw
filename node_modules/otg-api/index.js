"use strict";

var net = require('net'),
    rl  = require('readline'),
    otg = require('./lib/otg_const'),
    ot  = require('./lib/ot_msg'),
    otf = require('./lib/ot_func');

// Map sensor types to Homey events
var sensorEventMap = {
	temperature: 'measure_temperature',
	pressure: 'measure_pressure',
	humidity: 'measure_humidity',
	co2: 'measure_co2',
	flow: '',
	percentage: '',
	binary: ''
};

var debugOn = false;
var client; // Net client
var timer;
var locale = Homey.manager('i18n').getLanguage();
var sendQueue = [];
var responseQueue = [];
var expectingResponse = false;
var fwMajorVersion = 3;
var gatewayMode = false; // false: Monitor mode; true: Gateway mode
var found = false; // True once an OpenTherm Gateway has been found
var searching = false; // Searching for OTG is in progress
var values = {}; // Values for all OpenTherm message values
var msg_supported = {}; // Will fill with supported messages
var searchCnt; // Nr of tries to find OTG
var map = {}; // Per OT variable name an array of devices: device func, device info ({func:, device: })
var settings = { 
	features: { permanent: '1', ventilation: '0' }, 
	config: {} // OTG configuration
};

function otgFlame2text(value) {
	return (value == 1 ? 'Heating' : 'Flame off');
}

function otgBar2mbar(value) {
	return (value * 1000);
}

// Map Homey events to get functions
var eventGetMap = {
	'thermostat_state': otgFlame2text,
	'measure_pressure': otgBar2mbar
};

function debug(text) {
	if (debugOn) {
		var now = new Date();
		if (typeof text == 'object') {
			var output = '';
			for (var property in text) {
			  output += property + ': ' + text[property]+'; ';
			};
			text = output;
		}
		var time = now.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/, "$1");
		var ms = ('00' + now.getMilliseconds()).slice(-3);
		Homey.log(time + '.' + ms + ' ' + text);
	}
}

var self = module.exports = {
	// debug function
	debug: debug,
	// Update local config & write new configuration to the OTG
	updateConfig: function(updates) {
		var dirty = {};
		for (var id in updates) {
			var cat = updates[id].var;
			var list = updates[id].val;
			for (var item in list) {
				var value = list[item];
				if (value != null && settings[cat][item] != value) {
					debug(item + '=');
					debug(value);
					settings[cat][item] = value;
					dirty += { id: cat, var: item, val: value };
				}
			}
		}
		// Write new configuration settings
		if (found && dirty.length > 0) {
			// TODO: don't re-initiate search, just do what's needed
			otgSendInit();
		}
	},
	// Open communication
	openComm: function(ip, port) {
		found = false; // openComm always triggers a new search
		searchCnt = 0;
		debug('Starting search on ' + ip + ':' + port);
		if (client) {
			client.destroy();
		}
		var ok = ip != null && port != null;
		if (ok) {
			client = new net.Socket();
			// Setup a timer that we don't wait too long while searching
			timer = setTimeout(function() {
				debug('Timed out');
				client.end();
				Homey.manager('api').realtime('found_otg', false);
			}, 2000);
			var line = rl.createInterface(client, client);
			line.on('line', function(data) {
				clearTimeout(timer);
				otgProcessData(data);
			});
			client.on('error', function(err) {
				clearTimeout(timer);
				client.destroy();
				debug(err);
				Homey.manager('api').realtime('found_otg', false);
			});
			client.connect(port, ip, function() {
				debug('Connected to ' + ip + ':' + port);
				// Search for the OTG
				otgSearch(false);
			});
		}
		return ok;
	},
	// Check if we have found an OTG (true/false)
	checkFound: function() {
		return found;
	},
	// Set OTG configuration text & settings
	getGatewayConfig: function() {
		return settings.config;
	},
	// Get list of thermostats
	getThermostats: function() {
		var devices = [{ 
				name: (locale == 'nl' ? "Thermostaat" : "Thermostat"),
				data: { 
					id: "OTG:T1", 
					watch: [
						{ variable: 'CurrentTemperature', event: 'measure_temperature' },
						{ variable: 'CurrentSetpoint', event: 'target_temperature' },
						{ variable: 'RemoteOverrideRoomSetpoint', event: 'target_temperature' },
						{ variable: 'StatusFlame', event: 'thermostat_state' }
					]
				},
			}];
		if (msg_supported[23]) {
			devices[1] = { 
				name: (locale == 'nl' ? "Verwarming 2" : "Heating 2"),
				data: { 
					id: "OTG:T2", 
					watch: [
						{ variable: 'CH2CurrentSetpoint', event: 'target_temperature' }
					]
				},
			};
		}
		return devices;
	},
	// Get list of sensors of type <sort>
	getSensors: function(sort) {
		var devices = [];
		var cnt = 0;
		for (var nr in ot.Messages) {
			var msg = ot.Messages[nr];
			// If sort is not defined, show all types, but only if the message already has a value.
			// We want to prevent to show sensors that are not supported by either boiler or thermostat.
			if ((sort == null || msg.sensor == sort) && values[msg.var]) {
				devices[cnt++] = {
					name: msg[locale] || msg.en,
					data: {
						id: 'OTG:' + nr,
						watch: [{ variable: msg.var, event: sensorEventMap[msg.sensor] }]
					}
				};
			}
		}
		return devices;
	},
	// Add a OTG device
	addDevice: function(func, device) {
		debug("Adding device " + device.id);
		if (device.watch) {
			device.watch.forEach(function(element) {
				if (map[element.variable] == null) {
					map[element.variable] = [];
				}
				debug("Watching variable " + element.variable);
				if (element.get) {
					// We need to evaluate the function call at this point.
					element.get = eval(element.get);
				};
				// Add information of the device to our real-time update map
				map[element.variable].push({ func: func, device: device, event: element.event });
				// Immediately send a (forced) update of the variable if available
				otgUpdateIfNeeded(element.variable, values[element.variable], true);
			});
		}
	},
	// Remove an OTG device
	deleteDevice: function(device) {
		debug("Deleting device " + device.id);
		for (var id in device.watch) {
			// Remove this device from the map
			var name = device.watch[id].variable;
			debug("Un-watching " + name);
			delete map[name];
		}
	},
	// Get an OTG variable value for a certain event
	getValue: function(event, variable) {
		var value = values[variable];
		if (value != null) {
			var get = eventGetMap[event];
			if (typeof get == 'function') {
				value = get(value);
			}
		}
		return value;
	},
	// Set the target temperature
	setTargetTemp: function(device, value) {
		if (device.id == 'OTG:T1' && gatewayMode) {
			var cmd = 'TT='; // temporary temperature
			debug(settings.features);
			if (settings.features.permanent == '1') {
				cmd = 'TC='; // constant temperature
			}
			otgWriteCommand(cmd + value);
		} else if (device.id == 'OTG:T2' && gatewayMode) {
			// TODO: figure out to use SR command
			debug('Second thermostat not supported yet');
		}
	},
	// Get the current mode of the thermostat
	getThermostatMode: function(device) {
		var state = (values.RemoteOverrideRoomSetpoint > 0 ? 'heat' : 'auto'); // TODO: test
		return state;
	},
	// Set the mode of the thermostat: auto = resume program
	setThermostatMode: function(device, mode) {
		if (mode == 'auto' && gatewayMode) {
			otgWriteCommand('TT=0');
		}
	},
	// Get the state of the boiler (e.g. flame state)
	getThermostatState: function(device) {
		var state = '<tbd>';
		if (values.StatusFlame !== null) {
			state = otgFlame2text(values.StatusFlame);
		}
		return state;
	},
	// Use another sensor to set the outside temperature
	setOutsideTemperature: function(NewTemperature) {
		debug("setOutsideTemperature " + (NewTemperature | ''));
		if (gatewayMode) {
			otgWriteCommand('OT=' + NewTemperature); // Outside temperature
		}
	},
	// Use another sensor to update the measured humidity
	setRoomHumidity: function(NewLevel) {
		debug("setRoomHumidity " + (NewLevel | ''))
		if (gatewayMode) {
			otgWriteCommand('SR=78:' + NewLevel + ",0"); // Outside temperature
		}
	}	
}

// Write a message or enqueue
function otgWriteCommand(cmd, response) {
   if (cmd == null) {
      if (sendQueue.length > 0) {
         var val = sendQueue.shift();
         return otgWriteCommand(val.cmd, val.ret)
      } else {
         return false
      }
   } else if (responseQueue.length == 0) {
      client.write(cmd + '\r');
      debug("Sent command " + cmd)
      if (response != null && response == true) {
         otgUpdateIfNeeded("CommandResponse", "");
         expectingResponse = true;
      } else if (response == null) {
         if (fwMajorVersion >= 4) {
            response = cmd.replace(/=/, ": ");
            response = response.replace(/,/g, "/");
         } else {
            response = "OK";
         }
         responseQueue.push(response);
      } else if (typeof response == 'string') {
         responseQueue.push(response);
      }
   } else {
      sendQueue.push({cmd: cmd, ret: response});
   }
}

// Update variable value if needed and send message to Homey
function otgUpdateIfNeeded(name, newValue, forced) {
	if (name != null && newValue != null && (values[name] != newValue || forced)) {
		values[name] = newValue;
		debug('Updating value of ' + name + ' to ' + newValue);
		if (map[name]) {
			map[name].forEach(function(element) {
				var get = eventGetMap[element.event];
				if (typeof get == 'function') {
					newValue = get(newValue);
				}
				debug("Sending real-time event " + element.event + " for device " + element.device.id + ' (' + name + '=' + newValue + ')');
				element.func.realtime(element.device, element.event, newValue);
			});
		}
	}
}

// Add a configuration setting we just found
function otgAddConfig(idx, val) {
	var name = otg.Config[idx].var;
	var tab = otg.Config[idx].tab;
	var cnt = otg.Config[idx].cnt;
	var loop = cnt || 1;
	debug('Setting read: ' + name + ' = ' + val);
	for (var i = 0; i < loop; i++) {
		var txtVal = val;
		var txtName = otg.Config[idx][locale] || otg.Config[idx].en; // default to English if needed
		var itemVal = val;
		var itemName = name;
		if (cnt != null) {
			itemName = name + i;
			itemVal = val[i];
			txtName = txtName.replace(/<(.)>/, function(x) { return String.fromCharCode(x[1].charCodeAt(0) + i) });
		}
		if (tab != null) {
			txtVal = otg[tab][itemVal][locale] || otg[tab][itemVal].en; // default to English if needed
		}
		settings.config[itemName] = { txt: txtName, val: itemVal, txtVal: txtVal, mod: otg.Config[idx].cmd != null };
	}
	Homey.manager('api').realtime('config_change', settings.config);
}

// Search for OTG
function otgSearch() {
	if (found == false && searchCnt++ < 3) {
		otgWriteCommand('PR=' + otg.Config.VER.rep, "VER");
		setTimeout(otgSearch, 1000);
		debug("Search attempt " + searchCnt);
	} else if (found == false) {
		Homey.manager('api').realtime('found_otg', false);
	}
}

// Send initialization commands
function otgSendInit() {
	// Fake ventilation if needed
	if (settings.features.ventilation == '1') {
		otgWriteCommand('SR=70:0,0');
	} else {
		otgWriteCommand('CR=70');
	}
	// Read Gateway settings to store them locally
	for (var i = 0; i < otg.Startup.length; i++) {
		var item = otg.Startup[i];
		if (otg.Config[item] && otg.Config[item].rep) {
			var cmd = 'PR=' + otg.Config[item].rep;
			otgWriteCommand(cmd, item);
		}
	}
}

// Local data processing function
function otgProcessData(data) {
	var str = String(data);
	var res = str.match(/(A|B|R|T)[0-9A-F]{8}/);
	if (res != null) { 
		// Found OpenTherm communication data
		var sender = otg.Initiator[str[0]];
		var ctype = otg.MsgType[parseInt(str[1], 16) & 0x7];
		var msg = parseInt(str.substr(3, 2), 16);
		if (ot.Messages[msg] != null) {
			var msgName = ot.Messages[msg].txt;
			var val1 = parseInt(str.substr(5, 2), 16);
			var val2 = parseInt(str.substr(7, 2), 16);
			var val = 0

			// Keep track of unsupported message IDs
			var override = (sender == "Answer" || sender == "Response");
			if ((ctype == "Read-Ack" || ctype == "Write-Ack") && msg_supported[msg] == null && override == false) {
				msg_supported[msg] = true;
			}
 
			// Determine if the value received will update the variable
			var valid = false;
			if (ctype == "Read-Ack") {
				valid = (override == true && msg_supported[msg] == null) || (override == false && msg_supported[msg] != null);
			} else if (ctype == "Write-Data") {
				valid = true;
			} else if (ctype == "Data-Invalid") {
				valid = override;
			}

			if (valid == true) {
				// Format value
				var msgVal = ot.Messages[msg].val;
				if (typeof msgVal === 'object') {
					val = otf.decode(val1, msgVal.hb) + ' ' + otf.decode(val2, msgVal.lb)
				} else {
					val = otf.decode(val1, msgVal, val2)
				}
				var variable = ot.Messages[msg].var;
				if (variable != null) {
					if (typeof variable == 'object') {
						otgUpdateIfNeeded(variable.hb, val1);
						otgUpdateIfNeeded(variable.lb, val2);
					} else {
						otgUpdateIfNeeded(variable, val);
					}
				}

				// If needed: format flags
				var msgFlags = ot.Messages[msg].flags;
				if (msgFlags != null) {
					msgFlags = ot[msgFlags];
					val = val1 * 256 + val2;
					for (var flag in msgFlags) {
						var item = msgFlags[flag];
						var flagVal = (val & parseInt(flag, 16)) ? 1 : 0;
						//debug(">> " + item.txt + ": " + flagVal);
						if (item.var != null) {
							otgUpdateIfNeeded(item.var, flagVal)
						}
					}
				}
			}
			//debug(res[0] + ' ' + sender + ', ' + ctype + ', ' + msgName + ': ' + val);
		 } else {
			debug('Unknown OpenTherm message ID ' + msg);
		}
	} else if (expectingResponse == true) { // Receive queue handling
		otgExpectingResponse = false
		otgUpdateIfNeeded("CommandResponse", str);
	} else if (responseQueue.length > 0) {
		var elem = responseQueue.shift();
		var elem_t = otg.Config[elem];
		if (elem_t != null) { // a known message
			var val = str.match(new RegExp(elem_t.ret)); // check expected response
			if (val != null) {
				val = val[1]; // matched item is in second entry
			}
			if (val != null && elem_t.map != null) { // apply mapping if available
				for (var key in elem_t.map) {
					if (val.match(key) != null) {
						val = elem_t.map[key];
					}
				}
			}
			if (val != null) { // valid response
				otgAddConfig(elem, val);
				// call specific message handler (if available)
				if (elem_t.handler != null) {
				   elem_t.handler(data, val);
				}
			} else {
				debug("Error for cmd: " + elem + "; expected " + elem_t.ret + " but got " + str);
			}
		} else if (str.match(elem) == null && str.match(/: NF/) == null) { // Ignore NF (Not Found) errors
			 debug("Error: expected " + elem + " but got " + str);
			 // Put expected message back on top of queue
			 responseQueue.unshift(elem);
		} else {
			// Other OTG traffic
			debug(str);
		}
		otgWriteCommand(); // Write next command if there is one in the queue
	}
}

// Message handlers
otg.Config.VER.handler = function(cmd, version) {
	// Found PR=A (version information)
	fwMajorVersion = version.match(/\d/);
	found = true;
	Homey.manager('api').realtime('found_otg', true);
	debug("Found OpenTherm Gateway firmware version " + version + ' (major=' + fwMajorVersion + ')');
	// Update configuration based on version
	if (otg.VersionConfig[fwMajorVersion]) {
		for (var key in otg.VersionConfig[fwMajorVersion]) {
			if (otg.Config[key] == null) {
				otg.Config[key] = {}; // new command
			}
			for (var x in otg.VersionConfig[fwMajorVersion][key]) {
				otg.Config[key][x] = otg.VersionConfig[fwMajorVersion][key][x];
			}
		}
	}
	otgSendInit();
}

otg.Config.GW.handler = function(cmd, mode) {
	gatewayMode = (mode == '1');
	debug('Gateway mode is now ' + gatewayMode);
}