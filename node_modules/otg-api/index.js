"use strict";

var net = require('net'),
	rl  = require('readline'),
    otg = require('./lib/otg_const'),
    ot  = require('./lib/ot_msg'),
    otf = require('./lib/ot_func');

var client;
var found = false; // True once an OpenTherm Gateway has been found
var searching = false; // Searching for OTG is in progress
var values = {}; // Values for all OpenTherm message values
var msg_supported = {}; // Will fill with supported messages
var ip_addr;
var ip_port;
var searchCnt; // Nr of tries to find OTG
var map = {}; // Per OT message nr: device func, device info ({func:, device: })
var features = { 'permanent': '1' };

var self = module.exports = {
	// Open communication
	openComm: function(ip, port) {
		found = false; // openComm always triggers a new search
		searchCnt = 0;
		Homey.log('Starting search on ' + ip + ':' + port);
		if (client) {
			client.destroy();
		}
		var ok = ip != null && port != null;
		if (ok) {
			client = new net.Socket();
			var line = rl.createInterface(client, client);
			line.on('line', function(data) {
				otgProcessData(data);
			});
			client.on('error', function(err) {
				client.destroy();
			});
			client.connect(port, ip, function() {
				Homey.log('Connected to ' + ip + ':' + port);
				client.write('\r');
				// Search for the OTG
				otgSearch(false);
				// TODO: add other init commands
			});
		}
		return ok;
	},
	// Check if we have found an OpenTherm Gateway
	checkFound: function() {
			return found;
	},
	// Set driver specific features
	setFeatures: function(settings) {
		var ok = settings != null;
		if (ok) {
			// TODO: input validation
			features = settings;
		}
		return ok;
	},
	addDevice: function(func, device, sort) {
		Homey.log("Adding device " + device.id);
		if (sort == 'thermostat') {
			map['16'] = { func: func, device: device };
			map['24'] = { func: func, device: device };
		} else {
			map[device.otid] = { func: func, device: device };
		}
	},
	deleteDevice: function(device) {
		Homey.log("Deleting device " + device.id);
		if (device.otid) {
			delete map[device.otid];
		}
	},
	getThermostats: function() {
		var devices = [{ data: { id: "OTG:T1" }, name: "Thermostat" }];
		return devices;
	},
	getValue: function(name) {
		return values[name];
	},
	setTargetTemp: function(value) {
		var cmd = 'TT='; // temporary temperature
		if (features['permanent'] == '1') {
			cmd = 'TC='; // constant temperature
		}
		client.write(cmd + value + '\r');
	},
	getSensors: function(sort) {
		var devices = [];
		if (sort != null) {
			// Return sensors that are of type 'sort'
			var cnt = 0;
			for (var nr in ot['Messages']) {
				var msg = ot['Messages'][nr];
				if (msg['sensor'] == sort && msg_supported[nr] == true) {
					devices[cnt++] = { data: { id: 'OTG:' + nr, otid: nr, variable: msg['var'] }, name: msg['txt'] };
				}
			}
		} else {
			// Return all sensors
		}
		return devices;
	}
}

// Update variable value if needed and send message to Homey
function otgUpdateIfNeeded(nr, name, newValue, event) {
	if (values[name] != newValue) {
		//Homey.log("Update for msgId " + nr);
		values[name] = newValue;
		if (map[nr]) {
			if (event == null) {
				event = 'measure_temperature';
			}
			//Homey.log("Sending real-time event " + event + " for device " + map[nr]['device']['id'] + ' (= ' + newValue + ')');
			map[nr]['func'].realtime(map[nr]['device'], event, newValue);
		}
	}
}

// Search for OTG
function otgSearch() {
	if (found == false && searchCnt++ < 3) {
		client.write('PR=A\r');
		setTimeout(otgSearch, 1000);
		Homey.log("Search attempt " + searchCnt);
	}
}

// Local data processing function
function otgProcessData(data) {
	var str = String(data);
	var res = str.match(/(A|B|R|T)[0-9A-F]{8}/);
	if (res != null) { 
		// Found OpenTherm communication data
		var sender = otg['Initiator'][str[0]];
		var ctype = otg['MsgType'][parseInt(str[1], 16) & 0x7];
		var msg = parseInt(str.substr(3, 2), 16);
		if (ot['Messages'][msg] != null) {
			var msgName = ot['Messages'][msg]['txt'];
			var val1 = parseInt(str.substr(5, 2), 16);
			var val2 = parseInt(str.substr(7, 2), 16);
			var val = 0

			// Keep track of unsupported message IDs
			var override = (sender == "Answer" || sender == "Response");
			if ((ctype == "Read-Ack" || ctype == "Write-Ack") && msg_supported[msg] == null && override == false) {
				msg_supported[msg] = true;
			}
 
			// Determine if the value received will update the variable
			var valid = false;
			if (ctype == "Read-Ack") {
				valid = (override == true && msg_supported[msg] == null) || (override == false && msg_supported[msg] != null);
			} else if (ctype == "Write-Data") {
				valid = true;
			} else if (ctype == "Data-Invalid") {
				valid = override;
			}

			// Format value
			var msgVal = ot['Messages'][msg]['val'];
			if (typeof msgVal === 'object') {
				val = otf['decode'](val1, msgVal['hb']) + ' ' + otf['decode'](val2, msgVal['lb'])
				var variable = ot['Messages'][msg]['var'];
				if (variable != null && valid) {
					var ev1, ev2;
					if (ot['Messages'][msg]['event'] != null) {
						ev1 = ot['Messages'][msg]['event']['hb']
						ev2 = ot['Messages'][msg]['event']['lb']
					}
					otgUpdateIfNeeded(msg, variable['hb'], val1, ev1);
					otgUpdateIfNeeded(msg, variable['lb'], val2, ev2);
				}
			} else {
				val = otf['decode'](val1, msgVal, val2)
				var variable = ot['Messages'][msg]['var'];
				if (variable != null && valid) {
					otgUpdateIfNeeded(msg, variable, val, ot['Messages'][msg]['event']);
				}
			}
			//Homey.log(res[0] + ' ' + sender + ', ' + ctype + ', ' + msgName + ': ' + val);
		 }else {
			Homey.log('Unknown OpenTherm message ID ' + msg);
		}
	} else if (str.match(/OpenTherm Gateway/) != null) {
		// Found PR=A (version information)
		var fw_major = str.match(/\d/);
		found = true;
		Homey.emit('found');
		Homey.log("Found OpenTherm Gateway firmware version " + fw_major);
	} else {
		// Other OTG traffic
		Homey.log(str);
	}
}
